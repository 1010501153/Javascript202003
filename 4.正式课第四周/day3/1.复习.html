<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // parentNode
        // 代码：写作业；
        // 思路 ：组长
        // 定位   setInterval 
        // 晚上时间一定敲一下课件
        // class A{
        //     constructor(){
        //         this.a=1;
        //     }
        // }
        // let a = new A;
        // console.log(a); 

        // 
        // let fn=()=>{};
        // class Fn{
        //     constructor(){

        //     }
        //     getX(){

        //     }
        // }
        // class A extends Fn{
        //     constructor(){
        //         super();
        //     }
        // }

        // generator 函数
        // function* fn(){
        //     yield "a";
        //     if(true){

        //     }
        //     yield "b";
        // }
        // var f = fn();
        // f.next();

        // Symbol : 产生唯一的值
        // Set ： 用于数组去重;成员唯一；
        // var ary = [1,1,2,2,3,3,6];
        // console.log([...new Set(ary)]) 

        // 防抖和节流
        // 防抖： 非立即执行  立即执行;
        // 节流： 稀释函数的执行次数 时间戳和定时器版；
        // 性能优化；


        // 同步和异步
        // JS 是单线程，同一时间只能执行一行代码
        // 浏览器时多线程 ：可以同时执行多个任务

        // 在浏览器解析代码，浏览器会分析当前任务时同步任务还是异步任务，如果是异步任务，把这个异步任务放在等待队列中，继续会直接向下执行，当同步代码执行完以后，会去等待队列中去获取到最早到达执行的异步任务，让其放回主栈中执行
        // 定时器  ajax   事件    promise   async await ;
        // setTimeout(function(){
        // },1000);
        // for(let i =0;i<100;i++){
        // }
        // function fn(){
        //     setTimeout(function(){
        //     },200)
        // }
        // fn()



    
        
    </script>
</body>
</html>