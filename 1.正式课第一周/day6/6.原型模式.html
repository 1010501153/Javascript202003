<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        var ary1 = [12,3,4];
        var ary2 =[23,484,2];
        // push : ary1和ary2都能调用push这个方法；并且push这个方法就是向数组的末尾新增一项；
        ary1.push();
        ary2.push();
        ary1.push===ary2.push

        // 原型模式： 构造函数模式解决了私有属性的问题；原型模式解决了公有属性的问题；
        function Fn(){
            this.x = 100;
            this.y = 200;
            // 每当Fn执行一次，都会创建一个新的堆内存；堆内存对应一个新的空间地址；
            // this.getX=function(){
            //     console.log(this.x);
            // }
        }
        Fn.prototype.getX = function(){
            console.log(this.x);
        }
        // f1和f2是两个不同的实例；f1===f2-->false
        var f1 = new Fn();// {x:100,y:200}
        var f2 = new Fn();// {x:100,y:200}
        // x 和y都是f1和f2的私有属性；
        // 想给f1和f2新增一个方法；这个方法执行的时候可以得到当前实例属性名为x的属性值；
        // f1.x==f2.x
        //console.log(f1==f2);
        console.log(f1);
        console.log(f2);
        // console.log(f1.x==f2.x)
        // console.log(f1.getX===f2.getX)
        // f1.__proto__.getX();
        // f2.getX();
        // f1和f2公用了一个getX的空间地址；不需要每次创建实例都创建这个函数的堆内存；
        // 原型上的属性称为实例的公有属性，只要是这个类创建出来的实例都可以调用原型上的方法；
        // 会默认省略__proto__;
        console.log(f1.getX===f2.getX);// true
        // 1. 每一个函数数据类型天生自带一个prototype属性，这个属性的属性值是一个对象
        // 2. prototype的属性值天生自带一个constructor属性，其属性值就是当前原型所属的类
        // 3. 每一个实例天生自带一个__proto__属性,这个属性的属性值指向当前实例所属类的原型；
        // console.dir(Fn);

        // 类一定是函数；Array是一个内置的类；
        var ary = [12,3,4];
        var ary1 = [1,2];
        // Array.prototype.push=function(){}
        // ary.push();
        // ary是Array的一个实例；那么ary就可以使用Array原型(prototype)上的方法
        console.log(ary.push===ary1.push);// true
        console.log(ary.constructor);//Array 会默认通过__proto__向原型链上查找；

        
        
    
    
    
    </script>
</body>
</html>